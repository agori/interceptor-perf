= interceptor-perf

In JEE world sometimes you have to catch some kind of exceptions, for example +OptimistickLockException+, 
with the aim of presenting it in a meaningful manner to the user 
(for example, "another user has been faster then you. Retry!").

A JEE interceptor is a perfect place where to catch these exceptions. Anyway a call to +EntityManager.flush()+
inside the interceptor is required to ensure that none exception will be thrown out of its control. 

Anyway, this extra flush comes with a performance penalty. A +flush+ call causes a dirty check on every managed entity.
Keep in mind that flush always happen before commit (at least this is the default behavior), and that an interceptor
around an EJB (when +@TransactionAttribute(REQUIRES)+ is used) is executed inside the transaction (when CMT is used).

A consequence of these facts is that you have two calls to flush (manual flush + automatic flush). Two +em.flush()+ calls cost time,
depending on the number of managed entities and probably the entities by themself. 

This project gives a proof of this performance cost and show a very simple technique to undertake the problem. 
Indeed if you call 

----
em.clear();
----

just after flush, the second automatic flush will perform a complete dirty check against...nothing, with gain in performance.

